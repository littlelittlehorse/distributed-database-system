# B+ 树

上节提到，DBMS 使用一些特定的数据结构来存储信息:

- 内部元数据 : 数据库和系统的状态信息。
- 核心数据存储 : 数据库中 tuple 的存储。
- 临时数据结构 : 查询过程中构建的数据。
- 表索引 : 辅助数据结构，找到特定的 tuple。

本节将介绍存储 table index 最常用的树形数据结构：B+ Tree，Skip Lists，Radix Tree。

## 表索引

表索引根据列排序后的结果，建立数据结构，指向相应 tuple 的指针。

存在维护和存储成本:
- 维护成本: 数据的插入、删除、更新，需要同时更新索引结构。
- 存储成本: 索引自身需要占用存储空间。

因此对需要考虑表索引数量。


## B+ 树

B 表示 Blance 平衡，意味着树中叶子的高度差不会超过 1。

B 树和 B+ 树都是多叉平衡树，而不定是二叉平衡树，因为多叉树可以明显降低树的高度，减少 I/O 的次数

B 树和 B+ 树的区别在于，B 树的非叶子和叶子节点都存储关键字，B+ 树只有叶子节点存储关键字。

### MySQL 使用 B+ 树而非 B 树的原因

1. I/O 次数少: B+ 树只有叶子节点存储关键字，非叶子节点不存储指向关键字 tuple 的指针，因此相比于 B 树，B+ 树非叶子节点可以存储更多关键字，减少了 I/O 次数。
2. 查询效率稳定: B+ 树每次都需要找到叶子节点才能返回。
3. 便于范围查找: B+ 树叶子节点使用链表相连，遍历链表便可以完成范围查询。B 树范围查询需要使用对 B 树进行中序遍历。


B+树中非叶子节点存储的 key 是索引对应的 column 的值，value 是对应的叶子节点；叶子节点存储了 key 和 value，value 取值通常有两种方案:
- Record / Tuple id : 存储指向 tuple 的指针、或者可以定位 tuple 的 tuple id。
- tuple data : 存储 tuple data，但这种方式不使用用非聚簇索引(二级索引)，因为 DBMS 只能将 tuple 数据存储在一个 index 中，否则数据的存储会出现冗余，同时带来额外的维护成本。

此外，leaf node 还需要存储相邻 siblings 的地址以及其它一下元信息，如下图所示 :

![image](https://user-images.githubusercontent.com/95269537/168978675-f3a83e02-15c2-4e6b-b2cb-16512c63f528.png)

### 设计优化

#### 节点大小

B+ 树的最佳节点大小取决于磁盘的速度，想法是通过尽可能多的键/值对来分摊从磁盘读取节点到内存的成本。磁盘越慢，则构思节点大小越大。

此外，还需要根据负载，有些负载可能是区域扫描更多，而不是单键查找。

#### 合并的阈值？

_有些DBMS在半满时并不总是合并。_

_延迟合并操作可能会减少重组量。_

_DBMS 可能更好地发生下溢，然后定期重建整个树以重新平衡它。_

#### 变长的 KEY

B+ Tree 中**存储的 key 经常是变长的**(key 为 string 类型)，通常有三种手段来应对 :







